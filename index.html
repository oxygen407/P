<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
window.onload = () => {
  // --- DOM elements (expects these IDs from your UI) ---
  const userNameInput = document.getElementById('userName');
  const roomIdInput = document.getElementById('roomId');
  const chatLog = document.getElementById('chatLog');
  const chatForm = document.getElementById('chatForm');
  const chatInput = document.getElementById('chatInput');
  const btnHelp = document.getElementById('btnHelp');
  const btnOmok = document.getElementById('btnOmok');
  const btnClear = document.getElementById('btnClear');
  const membersEl = document.getElementById('members');
  const roomInfo = document.getElementById('roomInfo');

  const pixelCanvas = document.getElementById('pixelCanvas');
  const paletteEl = document.getElementById('palette');
  const omokCanvas = document.getElementById('omokCanvas');
  const omokStatus = document.getElementById('omokStatus');

  const modeDrawBtn = document.getElementById('modeDraw');
  const modeEraserBtn = document.getElementById('modeEraser');
  const modeGameBtn = document.getElementById('modeGame');
  const brushSizeSel = document.getElementById('brushSize');

  // Fallbacks for element absence
  if(!chatLog || !chatInput || !pixelCanvas) {
    console.error('필수 UI 요소가 없습니다. 스크립트가 올바른 HTML과 함께 사용되는지 확인하세요.');
    return;
  }

  // --- helpers ---
  const now = () => new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  function addSystem(msg, local=false) {
    const div = document.createElement('div');
    div.className = 'msg';
    div.innerHTML = `<span class="ts">[${now()}]</span> <span class="name">시스템</span> ${msg}`;
    if(local) div.style.color = '#8f8';
    chatLog.appendChild(div);
    chatLog.scrollTop = chatLog.scrollHeight;
  }
  function addChat(name, text, local=false) {
    const div = document.createElement('div');
    div.className = 'msg';
    div.innerHTML = `<span class="ts">[${now()}]</span> <span class="name">${escapeHtml(name)}</span> ${escapeHtml(text)}`;
    if(local) div.style.color = '#8f8';
    chatLog.appendChild(div);
    chatLog.scrollTop = chatLog.scrollHeight;
  }
  function escapeHtml(s=''){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  // --- P2P setup (HTTPS-ready + ICE, mesh discovery) ---
  // Use PeerJS HTTPS server + ICE servers for better connectivity on GitHub Pages
  const peerConfig = {
    host: 'peerjs-server.herokuapp.com',
    port: 443,
    secure: true,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'turn:openrelay.metered.ca:80', username:'openrelayproject', credential:'openrelayproject' }
      ]
    }
  };

  let nickname = (userNameInput && userNameInput.value) ? userNameInput.value.trim() : ('Guest' + Math.random().toString(36).slice(2,6));
  if(userNameInput) userNameInput.value = nickname;
  let roomId = (roomIdInput && roomIdInput.value) ? roomIdInput.value.trim().slice(0,6) : (new URLSearchParams(location.search).get('r') || Math.random().toString(36).slice(2,8).toUpperCase().slice(0,6));
  if(roomIdInput) roomIdInput.value = roomId;

  // create peer AFTER DOM loaded
  let peer = null;
  let myPeerId = '';
  const conns = {}; // peerId -> DataConnection (stores .name)
  function startPeer() {
    try {
      peer = new Peer(`room-${roomId}-${Math.random().toString(36).slice(2,8)}`, peerConfig);
    } catch(e) {
      addSystem('Peer 초기화 실패: ' + e, true);
      return;
    }
    peer.on('open', id => {
      myPeerId = id;
      addSystem(`내 ID: ${id}`, true);
      roomInfo && (roomInfo.textContent = `방: ${roomId} | ID: ${id}`);
      discoverLoop();
      setInterval(discoverLoop, 2500);
    });
    peer.on('connection', conn => {
      setupConn(conn);
    });
    peer.on('error', err => {
      addSystem('Peer 오류: ' + (err && err.message ? err.message : String(err)), true);
      console.error(err);
    });
  }

  // discover peers with same roomId prefix via listAllPeers (best-effort)
  function discoverLoop() {
    if(!peer || !peer.listAllPeers) return;
    try {
      peer.listAllPeers(peers => {
        peers.filter(id => id.startsWith(`room-${roomId}-`) && id !== myPeerId)
             .forEach(id => { if(!conns[id]) connectToPeer(id); });
      });
    } catch(e) {
      // listAllPeers may be disabled; ignore silently
      // If this fails for your PeerJS server, consider Firebase signaling (we can swap later)
    }
  }

  function connectToPeer(id) {
    try {
      const c = peer.connect(id, { reliable:true });
      c.on('open', ()=> {
        setupConn(c);
        // handshake: announce name and request sync
        safeSend(c, { type:'meta', name:nickname });
        safeSend(c, { type:'sync-request', from: myPeerId });
      });
      c.on('error', ()=>{});
    } catch(e){ /* ignore */ }
  }

  function setupConn(conn) {
    const pid = conn.peer;
    if(conns[pid]) {
      // already exist — attach handlers only
      // but keep one connection object
    } else {
      conns[pid] = conn;
    }
    conn.on('data', data => {
      handleIncoming(pid, data);
    });
    conn.on('open', () => {
      // send our meta so others know our name
      safeSend(conn, { type:'meta', name: nickname });
      addSystem(`연결: ${pid}`, true);
      updateMembers();
      // request sync from peer (they may be host of some state)
      safeSend(conn, { type:'sync-request', from: myPeerId });
    });
    conn.on('close', () => {
      delete conns[pid];
      addSystem(`퇴장: ${pid}`, true);
      updateMembers();
    });
  }

  function safeSend(conn, pkt){
    try{ if(conn && conn.open) conn.send(pkt); } catch(e){ /* ignore */ }
  }

  function broadcast(pkt){
    Object.values(conns).forEach(c => safeSend(c, pkt));
  }

  function updateMembers(){
    const names = [nickname];
    Object.values(conns).forEach(c => { if(c && c.name) names.push(c.name); });
    if(membersEl) membersEl.textContent = '참가자: ' + Array.from(new Set(names)).join(', ');
  }

  function handleIncoming(fromId, msg) {
    if(!msg || !msg.type) return;
    switch(msg.type) {
      case 'meta':
        if(conns[fromId]) conns[fromId].name = msg.name || fromId;
        updateMembers();
        break;
      case 'chat':
        addChat(msg.name || fromId, msg.text || '');
        break;
      case 'cmd':
        // simple: others broadcast; handle /help and /omok start
        if(msg.text === '/help') showHelp();
        if(msg.text === '/omok start') startOmokLocal(false);
        break;
      case 'draw':
        // draw stroke from peer
        incomingDraw(msg);
        break;
      case 'pixel':
        // legacy pixel cell change (if used) - ignore or apply
        break;
      case 'omok':
        handleOmokNetwork(msg);
        break;
      case 'sync-request':
        // peer asks for current state -> send sync
        sendFullSyncToPeer(fromId);
        break;
      case 'sync':
        // receive full state
        if(msg.pixel) importDrawingState(msg.pixel);
        if(msg.omok) importOmok(msg.omok);
        if(msg.meta && Array.isArray(msg.meta.names)) updateMembersFromList(msg.meta.names);
        break;
      case 'system':
        addSystem(msg.text || '', true);
        break;
      default:
        // ignore
        break;
    }
  }

  function sendFullSyncToPeer(peerId){
    const c = conns[peerId];
    if(!c) return;
    const pkt = { type:'sync', pixel: exportDrawingState(), omok: exportOmokState(), meta:{names:getNamesList()} };
    safeSend(c, pkt);
  }
  function updateMembersFromList(list){
    if(Array.isArray(list)) {
      if(membersEl) membersEl.textContent = '참가자: ' + Array.from(new Set(list)).join(', ');
    }
  }
  function getNamesList(){
    const arr = [nickname];
    Object.values(conns).forEach(c=>{ if(c.name) arr.push(c.name); });
    return Array.from(new Set(arr));
  }

  // --- Chat UI wiring ---
  if(chatForm) {
    chatForm.addEventListener('submit', e => {
      e.preventDefault();
      const txt = (chatInput.value || '').trim();
      if(!txt) return;
      if(txt.startsWith('/')) {
        // local handle and broadcast as cmd
        handleLocalCmd(txt);
        broadcast({ type:'cmd', text: txt, from: nickname });
      } else {
        addChat(nickname, txt, true);
        broadcast({ type:'chat', name: nickname, text: txt });
      }
      chatInput.value = '';
    });
  }
  if(btnHelp) btnHelp.addEventListener('click', ()=>{ handleLocalCmd('/help'); broadcast({type:'cmd', text:'/help', from:nickname}); });
  if(btnClear) btnClear.addEventListener('click', ()=>{ chatLog.innerHTML=''; broadcast({type:'cmd', text:'/clear', from:nickname}); });

  function addChat(name, text, local=false){ addChat(name, text, local); } // placeholder to keep API consistent
  function showHelp(){
    addSystem('=== 명령어 ===', true);
    for(const k in commands) addSystem(`${k} — ${commands[k]}`, true);
  }

  const commands = {'/help':'명령어 목록', '/omok start':'오목 시작', '/clear':'채팅 지우기'};

  function handleLocalCmd(cmd) {
    if(cmd === '/help') {
      addSystem('=== 명령어 ===', true);
      for(const k in commands) addSystem(`${k} — ${commands[k]}`, true);
    } else if(cmd === '/omok start') {
      startOmokLocal(true); // local and broadcast
    } else if(cmd === '/clear') {
      chatLog.innerHTML='';
      addSystem('채팅이 지워졌습니다.', true);
    } else {
      addSystem('알 수 없는 명령어', true);
    }
  }

  // --- Drawing canvas (freehand brush, small sizes, correct coords) ---
  const drawCanvas = pixelCanvas; // keep naming consistent with UI
  const dctx = drawCanvas.getContext('2d');
  let currentMode = 'draw'; // draw | eraser | game
  let brushSize = (brushSizeSel ? parseInt(brushSizeSel.value || '3') : 3);
  let drawing = false;
  let last = null;

  // ensure canvas is sized to element display size and scale internal resolution for crisp lines
  function resizeDrawCanvas() {
    const rect = drawCanvas.getBoundingClientRect();
    // use devicePixelRatio scaling for crisp lines
    const dpr = window.devicePixelRatio || 1;
    drawCanvas.width = Math.max(300, Math.floor(rect.width * dpr));
    drawCanvas.height = Math.max(300, Math.floor(rect.height * dpr));
    drawCanvas.style.width = `${rect.width}px`;
    drawCanvas.style.height = `${rect.height}px`;
    dctx.lineCap = 'round'; dctx.lineJoin = 'round';
    redrawGridOverlayIfNeeded();
  }
  // redraw grid (if your UI expects a grid drawn by separate canvas, that remains untouched)
  function redrawGridOverlayIfNeeded(){ /* no-op: your existing CSS grid canvas remains; this ensures draw canvas matches size */ }

  // pointer event coordinates mapping to canvas internal coords
  function getCanvasPos(evt) {
    const rect = drawCanvas.getBoundingClientRect();
    const dpr = (window.devicePixelRatio || 1);
    const x = Math.round((evt.clientX - rect.left) * dpr);
    const y = Math.round((evt.clientY - rect.top) * dpr);
    return { x, y };
  }

  // incoming draw strokes from peers
  function incomingDraw(pkt) {
    if(!pkt) return;
    try {
      dctx.save();
      dctx.globalCompositeOperation = 'source-over';
      dctx.strokeStyle = pkt.color || '#00ff00';
      dctx.lineWidth = pkt.width || 2;
      dctx.beginPath();
      dctx.moveTo(pkt.fromX, pkt.fromY);
      dctx.lineTo(pkt.toX, pkt.toY);
      dctx.stroke();
      dctx.restore();
    } catch(e){ console.warn('incomingDraw error', e); }
  }

  // export/import drawing state (simple base64 snapshot)
  function exportDrawingState(){
    try { return { img: drawCanvas.toDataURL() }; }
    catch(e){ return null; }
  }
  function importDrawingState(state){
    if(!state || !state.img) return;
    const img = new Image();
    img.onload = ()=> { dctx.drawImage(img, 0, 0, drawCanvas.width, drawCanvas.height); };
    img.src = state.img;
  }

  // broadcast stroke piece (small objects)
  function broadcastStroke(fromX, fromY, toX, toY, color, width){
    const pkt = { type:'draw', fromX, fromY, toX, toY, color, width };
    broadcast(pkt);
  }

  // pointer events
  drawCanvas.addEventListener('pointerdown', e => {
    if(currentMode === 'game') return;
    drawing = true;
    last = getCanvasPos(e);
  });
  drawCanvas.addEventListener('pointermove', e => {
    if(!drawing || currentMode === 'game') return;
    const pos = getCanvasPos(e);
    const color = (currentMode === 'eraser') ? '#000000' : (window.getComputedStyle ? window.getComputedStyle(drawCanvas).color || '#00ff00' : '#00ff00');
    dctx.strokeStyle = (currentMode === 'eraser') ? '#000000' : (selectedColor || '#00ff00');
    dctx.lineWidth = brushSize * (window.devicePixelRatio || 1);
    dctx.beginPath();
    dctx.moveTo(last.x, last.y);
    dctx.lineTo(pos.x, pos.y);
    dctx.stroke();
    // broadcast normalized coords (we transmit internal canvas coords)
    broadcastStroke(last.x, last.y, pos.x, pos.y, dctx.strokeStyle, dctx.lineWidth);
    last = pos;
  });
  drawCanvas.addEventListener('pointerup', e => { drawing = false; last = null; });
  drawCanvas.addEventListener('pointercancel', () => { drawing = false; last = null; });
  drawCanvas.addEventListener('pointerout', () => { drawing = false; last = null; });

  // brush controls
  if(brushSizeSel) brushSizeSel.addEventListener('input', ()=> { brushSize = parseInt(brushSizeSel.value || '3'); });
  if(modeDrawBtn) modeDrawBtn.addEventListener('click', ()=> { currentMode='draw'; modeDrawBtn.disabled=true; modeEraserBtn.disabled=false; modeGameBtn.disabled=false; });
  if(modeEraserBtn) modeEraserBtn.addEventListener('click', ()=> { currentMode='eraser'; modeEraserBtn.disabled=true; modeDrawBtn.disabled=false; modeGameBtn.disabled=false; });
  if(modeGameBtn) modeGameBtn.addEventListener('click', ()=> { handleLocalCmd('/omok start'); broadcast({type:'cmd', text:'/omok start', from:nickname}); });

  // color palette (if paletteEl exists) - simple default set
  let selectedColor = '#00ff00';
  function buildPalette(){
    if(!paletteEl) return;
    const colors = ['#000000','#ffffff','#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#ff8800','#888888'];
    paletteEl.innerHTML = '';
    colors.forEach(c => {
      const d = document.createElement('div');
      d.className = 'sw';
      d.style.background = c;
      d.style.width = '20px'; d.style.height='20px'; d.style.margin='2px'; d.style.cursor='pointer';
      d.addEventListener('click', ()=> { selectedColor = c; /* update visual */ });
      paletteEl.appendChild(d);
    });
  }

  // --- Omok logic (local-start, network sync) ---
  const OM = { n:15, board:[], playing:false, order:[], turnIndex:0 };
  function omokReset(){ OM.board = Array.from({length:OM.n}, ()=> Array(OM.n).fill(0)); OM.playing=false; OM.order=[]; OM.turnIndex=0; drawOmok(); omokCanvas.classList.add('hidden'); omokStatus && (omokStatus.classList.add('hidden')); currentMode='draw'; }
  function startOmokLocal(broadcastStart=true){
    // deterministic order: names sorted to avoid race
    OM.order = getNamesList().slice().sort();
    OM.board = Array.from({length:OM.n}, ()=> Array(OM.n).fill(0));
    OM.playing = true; OM.turnIndex = 0;
    drawOmok();
    omokCanvas.classList.remove('hidden');
    omokStatus && (omokStatus.classList.remove('hidden'));
    setOmokStatus();
    if(broadcastStart) broadcast({type:'omok', action:'start', omok: exportOmokState()});
    currentMode = 'game';
  }

  function setOmokStatus(){ if(omokStatus) omokStatus.textContent = `오목 — 턴: ${OM.order[OM.turnIndex] || '(대기)'}`; }

  // ensure omokCanvas size matches display (using CSS size if any)
  function resizeOmokCanvas(){
    if(!omokCanvas) return;
    const rect = omokCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    omokCanvas.width = Math.floor(rect.width * dpr) || OM.n * 20;
    omokCanvas.height = Math.floor(rect.height * dpr) || OM.n * 20;
    drawOmok();
  }

  function drawOmok(){
    if(!omokCanvas) return;
    const ctx = omokCanvas.getContext('2d');
    ctx.clearRect(0,0,omokCanvas.width,omokCanvas.height);
    const c = Math.floor(omokCanvas.width / OM.n);
    ctx.strokeStyle = '#19ff19';
    ctx.lineWidth = 1;
    for(let i=0;i<OM.n;i++){
      ctx.beginPath(); ctx.moveTo(c/2, c/2 + i*c); ctx.lineTo(omokCanvas.width-c/2, c/2 + i*c); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(c/2 + i*c, c/2); ctx.lineTo(c/2 + i*c, omokCanvas.height - c/2); ctx.stroke();
    }
    for(let y=0;y<OM.n;y++){
      for(let x=0;x<OM.n;x++){
        const v = OM.board[y][x];
        if(!v) continue;
        ctx.beginPath();
        ctx.fillStyle = (v===1? '#000' : '#fff');
        ctx.arc(c/2 + x*c, c/2 + y*c, c*0.38, 0, Math.PI*2);
        ctx.fill();
        ctx.lineWidth = 1; ctx.strokeStyle = '#19ff19'; ctx.stroke();
      }
    }
  }

  // omok canvas click handler
  if(omokCanvas) {
    omokCanvas.addEventListener('click', e => {
      if(!OM.playing) return;
      const rect = omokCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const px = omokCanvas.width / OM.n;
      const x = Math.floor((e.clientX - rect.left) * dpr / px);
      const y = Math.floor((e.clientY - rect.top) * dpr / px);
      if(x<0 || y<0 || x>=OM.n || y>=OM.n) return;
      const cur = OM.order[OM.turnIndex];
      if(cur !== nickname) { addSystem('지금은 당신의 턴이 아닙니다.'); return; }
      if(OM.board[y][x] !== 0) return;
      const stone = (OM.turnIndex % 2 === 0) ? 1 : 2;
      OM.board[y][x] = stone;
      drawOmok();
      broadcast({ type:'omok', action:'place', x, y, stone, by: nickname });
      if(checkOmokWin(x,y,stone)){
        OM.playing = false;
        addSystem(`${nickname} 님이 오목에서 승리했습니다!`, true);
        broadcast({ type:'omok', action:'end', winner: nickname });
        setTimeout(()=> omokReset(), 1200);
        return;
      }
      OM.turnIndex = (OM.turnIndex + 1) % OM.order.length;
      setOmokStatus();
    });
  }

  function handleOmokNetwork(msg){
    if(!msg || !msg.action) return;
    if(msg.action==='start') startOmokLocal(false);
    else if(msg.action==='place'){
      if(OM.board[msg.y][msg.x] === 0) OM.board[msg.y][msg.x] = msg.stone;
      drawOmok();
      const idx = OM.order.indexOf(msg.by);
      if(idx >= 0) OM.turnIndex = (idx + 1) % OM.order.length;
      setOmokStatus();
    } else if(msg.action==='end'){
      OM.playing=false;
      addSystem(`${msg.winner} 님이 오목에서 승리했습니다!`, true);
      setTimeout(()=> omokReset(), 1200);
    } else if(msg.action==='sync' && msg.omok) {
      importOmok(msg.omok);
    }
  }

  function checkOmokWin(x,y,stone){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for(const [dx,dy] of dirs){
      let cnt=1;
      for(let s=1;s<5;s++){ const nx=x+dx*s, ny=y+dy*s; if(nx<0||ny<0||nx>=OM.n||ny>=OM.n) break; if(OM.board[ny][nx]===stone) cnt++; else break; }
      for(let s=1;s<5;s++){ const nx=x-dx*s, ny=y-dy*s; if(nx<0||ny<0||nx>=OM.n||ny>=OM.n) break; if(OM.board[ny][nx]===stone) cnt++; else break; }
      if(cnt>=5) return true;
    }
    return false;
  }

  function importOmok(obj){ if(!obj) return; OM.board = obj.board || OM.board; OM.order = obj.order || OM.order; OM.playing = obj.playing || OM.playing; OM.turnIndex = obj.turnIndex || OM.turnIndex; drawOmok(); if(OM.playing){ omokCanvas.classList.remove('hidden'); omokStatus && omokStatus.classList.remove('hidden'); setOmokStatus(); } }
  function exportOmokState(){ return { board: OM.board, order: OM.order, playing: OM.playing, turnIndex: OM.turnIndex }; }

  // handle omok messages from network
  function handleOmokMessage(msg){ handleOmokNetwork(msg); }

  // --- misc helpers ---
  function getNamesList(){ return getNamesList; } // kept for compatibility if needed

  // initial build
  buildPalette();
  resizeDrawCanvas();
  window.addEventListener('resize', ()=>{ resizeDrawCanvas(); resizeOmokCanvas(); drawOmok(); });

  // start Peer
  startPeer();

  // Expose some functions to console for debugging
  window.__p2p = { peer, conns, broadcast };
};
</script>