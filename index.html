<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>P2P 채팅</title>
<style>
:root{--bg:#0b0f0c;--panel:#111;--line:#0f0;--txt:#cfc;--muted:#8a8}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:#000;color:var(--txt);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.wrap{max-width:1280px;margin:10px auto;border:3px solid #0f0;box-shadow:0 0 0 4px #063 inset;padding:6px;min-height:calc(100% - 20px)}
.header{border:2px solid #0f0;margin:6px;padding:8px;text-align:center;font-weight:700;background:#010}
.topRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:6px}
.topRow input{background:#000;border:2px solid #0f0;color:#9f9;padding:6px 8px;border-radius:4px;min-width:120px}
.topRow .room{margin-left:auto;color:#9f9}

.main{display:grid;grid-template-columns:1fr 1fr;gap:10px;border-top:2px solid #060;border-bottom:2px solid #060;padding:8px;min-height:68vh}
.left,.right{border:2px solid #0f0;background:#010;min-height:560px;display:flex;flex-direction:column}
.left .log{flex:1;overflow:auto;padding:8px;border-bottom:2px solid #060}
.msg{line-height:1.4}.msg .ts{color:#8f8;margin-right:6px}.msg .name{color:#0f8;margin-right:6px}
.controls{display:flex;gap:6px;padding:8px}
.controls input[type=text]{flex:1;background:#000;border:2px solid #0f0;color:#9f9;padding:8px;border-radius:4px}
.controls button{background:#000;border:2px solid #0f0;color:#9f9;padding:8px 10px;border-radius:4px;cursor:pointer}
.controls button:hover{filter:brightness(1.1)}
.members{padding:6px 8px;border-top:2px solid #060;font-size:14px;color:#9f9}

.right .toolbar{display:flex;gap:8px;padding:8px;border-bottom:2px solid #060;align-items:center;flex-wrap:wrap}
.right .canvasWrap{position:relative;flex:1;display:flex;flex-direction:column;padding:8px;gap:8px}
#pixelCanvas{width:100%;height:100%;background:#000;border:2px solid #0f0;touch-action:none}
.grid{position:absolute;top:8px;left:8px;right:8px;bottom:60px;
  background:linear-gradient(#003a00 1px,transparent 1px) 0 0/20px 20px,
             linear-gradient(90deg,#003a00 1px,transparent 1px) 0 0/20px 20px}
.palette{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:6px}
.palette .sw{width:22px;height:22px;border:2px solid #0f0;cursor:pointer}
.palette .sw.sel{outline:3px solid #0f0}

@media (max-aspect-ratio: 9/10), (max-width: 900px){
  .main{grid-template-columns:1fr;min-height:auto}
  .left,.right{min-height:380px}
}

button:disabled{opacity:.6}
.footer{margin-top:8px;padding:6px;border:2px solid #0f0;text-align:center;color:#8f8}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">P2P 채팅</div>

  <div class="topRow">
    <input id="userName" placeholder="닉네임" value="Guest" />
    <input id="roomId" placeholder="방 ID" value="mainroom" readonly />
    <div class="room" id="roomInfo">방: mainroom | ID: -</div>
  </div>

  <div class="main">
    <div class="left">
      <div class="log" id="chatLog" aria-live="polite"></div>
      <form class="controls" id="chatForm" autocomplete="off">
        <input id="chatInput" type="text" placeholder="메시지 입력 — /help 로 명령어 확인" />
        <button type="submit">전송</button>
      </form>
      <div class="controls">
        <button id="btnHelp">/help</button>
        <button id="btnClear">채팅 지우기</button>
      </div>
      <div class="members" id="members">참가자: -</div>
    </div>

    <div class="right">
      <div class="toolbar">
        <button id="modeDraw">그리기</button>
        <button id="modeEraser">지우개</button>
        <label>브러쉬 크기: <input id="brushSize" type="range" min="1" max="10" value="2"></label>
      </div>
      <div class="canvasWrap">
        <div class="grid" aria-hidden="true"></div>
        <canvas id="pixelCanvas" width="560" height="560" aria-label="그림·오목 캔버스"></canvas>
        <div class="palette" id="palette"></div>
      </div>
    </div>
  </div>

  <div class="footer">시그널링: WebTorrent Trackers (HTTPS/WSS); 모든 데이터는 브라우저 간 전송됩니다.</div>
</div>

<!-- 원본: p2pt -->
<script src="https://unpkg.com/p2pt@latest/dist/p2pt.umd.min.js"></script>
<script>
/* ======== DOM ======== */
const userNameInput = document.getElementById('userName');
const roomIdInput   = document.getElementById('roomId'); // 변경됨: URL 방 ID 반영
const chatLog       = document.getElementById('chatLog');
const chatForm      = document.getElementById('chatForm');
const chatInput     = document.getElementById('chatInput');
const btnHelp       = document.getElementById('btnHelp');
const btnClear      = document.getElementById('btnClear');
const membersEl     = document.getElementById('members');
const roomInfo      = document.getElementById('roomInfo');

const modeDrawBtn   = document.getElementById('modeDraw');
const modeEraserBtn = document.getElementById('modeEraser');
const brushSizeInput= document.getElementById('brushSize');
const canvas        = document.getElementById('pixelCanvas');
const ctx           = canvas.getContext('2d');
const paletteEl     = document.getElementById('palette');

/* ======== 유틸 ======== */
function escapeHtml(s=''){ return String(s).replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
const now = () => new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
function addSystem(text, local=false){
  const d=document.createElement('div'); d.className='msg';
  d.innerHTML = `<span class="ts">[${now()}]</span> <span class="name">시스템</span> ${escapeHtml(text)}`;
  if(local) d.style.color='#8f8'; chatLog.appendChild(d); chatLog.scrollTop=chatLog.scrollHeight;
}
function addChat(name, text, local=false){
  const d=document.createElement('div'); d.className='msg';
  d.innerHTML = `<span class="ts">[${now()}]</span> <span class="name">${escapeHtml(name)}</span> ${escapeHtml(text)}`;
  if(local) d.style.color='#8f8'; chatLog.appendChild(d); chatLog.scrollTop=chatLog.scrollHeight;
}

/* ======== 방 링크 (URL) ======== */
const params = new URLSearchParams(location.search);                            // 변경됨: 방을 URL로 지정
const roomFromUrl = (params.get('room')||'mainroom').trim();
roomIdInput.value = roomFromUrl;                                               // 변경됨
const ROOM_TOPIC = 'p2pchat-' + roomFromUrl;                                   // 변경됨

/* ======== P2P 설정 ======== */
const TRACKERS = [
  'wss://tracker.openwebtorrent.com',
  'wss://tracker.btorrent.xyz',
  'wss://tracker.fastcast.nz',
  'wss://tracker.webtorrent.dev',
  'wss://tracker.files.fm:7073/announce'
];

const ICE_CONFIG = {                                                           // 변경됨: STUN/TURN 추가
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" },
    { urls: "stun:stun1.l.google.com:19302" },
    { urls: "turn:openrelay.metered.ca:80",  username: "openrelayproject", credential: "openrelayproject" },
    { urls: "turn:openrelay.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
    { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
  ]
};

let nickname = (userNameInput.value||'').trim()||'Guest';
userNameInput.addEventListener('change', ()=>{ nickname=(userNameInput.value||'').trim()||'Guest'; updateMembers(); });

const conns = {};
let p2pt=null;

function startP2P(){
  p2pt = new P2PT(TRACKERS, ROOM_TOPIC, { rtcConfig: ICE_CONFIG });            // 변경됨: rtcConfig 전달
  p2pt.on('peerconnect', peer=>{
    conns[peer.id] = {peer, name:null};
    roomInfo.textContent = `방: ${roomFromUrl} | ID: ${p2pt.peerId.slice(0,8)}`; // 변경됨
    safeSend(peer, {type:'meta',name:nickname});                                // 변경됨: 안전 직렬화
    updateMembers();
    // 처음 연결된 상대에게 현재 상태 동기화(옵션) — 필요시 주석 해제
    // safeSend(peer, {type:'sync', pixel: exportDrawing(), meta:{names: currentNames()}});
  });
  p2pt.on('peerclose', peer=>{
    delete conns[peer.id]; updateMembers();
  });
  p2pt.on('msg', (peer, data)=>{                                               // 변경됨: 수신 직렬화 처리
    let msg = data;
    try { if (typeof data === 'string') msg = JSON.parse(data); } catch(e){ return; }
    handleIncoming(peer.id, msg);
  });
  p2pt.on('warning', w=> addSystem('경고: '+w, true));                          // (진단용)
  p2pt.start();
  addSystem('P2P 시작됨', true);
}

function safeBroadcast(payload){                                                // 변경됨: JSON 직렬화 통일
  try{ if(p2pt) p2pt.broadcast(JSON.stringify(payload)); }catch(e){}
}
function safeSend(peer, payload){
  try{ p2pt.send(peer, JSON.stringify(payload)); }catch(e){}
}
function sendTo(peerId, payload){ const c=conns[peerId]; if(c) safeSend(c.peer, payload); }

function currentNames(){ return [nickname, ...Object.values(conns).map(c=>c.name).filter(Boolean)]; }
function updateMembers(){
  membersEl.textContent = '참가자: ' + Array.from(new Set(currentNames())).join(', ');
}

/* ======== 채팅 ======== */
chatForm.addEventListener('submit', e=>{
  e.preventDefault();
  const txt=(chatInput.value||'').trim(); if(!txt) return;
  if(txt.startsWith('/')){ handleLocalCmd(txt); safeBroadcast({type:'cmd', text:txt, from:nickname}); } // 변경됨
  else { addChat(nickname, txt, true); safeBroadcast({type:'chat', name:nickname, text:txt}); }         // 변경됨
  chatInput.value='';
});
btnHelp.addEventListener('click', ()=>{ showHelp(); safeBroadcast({type:'cmd', text:'/help', from:nickname}); }); // 변경됨
btnClear.addEventListener('click', ()=>{ chatLog.innerHTML=''; addSystem('채팅 지움', true); safeBroadcast({type:'cmd', text:'/clear', from:nickname}); }); // 변경됨

function handleIncoming(fromId, msg){
  if(!msg || !msg.type) return;
  if(msg.type==='meta'){ if(conns[fromId]) conns[fromId].name = msg.name||fromId; updateMembers(); }
  if(msg.type==='chat'){ addChat(msg.name||fromId, msg.text||''); }
  if(msg.type==='cmd'){
    if(msg.text==='/help') showHelp();
    if(msg.text==='/clear'){ chatLog.innerHTML=''; addSystem('채팅 초기화', true); }
  }
  if(msg.type==='draw'){ applyRemoteStroke(msg); }
}

function showHelp(){
  addSystem('=== 명령어 ===', true);
  addSystem('/help — 명령어 목록', true);
  addSystem('/clear — 채팅 지우기', true);
}

/* ======== 그림판 ======== */
let currentMode='draw';
let brushSize = parseInt(brushSizeInput.value||'2',10);
let selectedColor = '#00ff00';

const dpr = () => window.devicePixelRatio||1;
function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const r = dpr();
  const W = Math.max(320, Math.floor(rect.width*r));
  const H = Math.max(320, Math.floor(rect.height*r));
  if(canvas.width!==W || canvas.height!==H){
    const snapshot = exportDrawing();
    canvas.width=W; canvas.height=H;
    ctx.lineCap='round'; ctx.lineJoin='round';
    importDrawing(snapshot);
  }
}
window.addEventListener('resize', fitCanvas);

function buildPalette(){
  const colors=['#ffffff','#e74c3c','#f1c40f','#2ecc71','#3498db','#9b59b6','#e67e22','#a67c52',
                '#1abc9c','#2c3e50','#bdc3c7','#00ff00','#00ffff','#ff00ff','#ff66cc','#000000'];
  paletteEl.innerHTML='';
  colors.forEach(c=>{
    const el=document.createElement('div'); el.className='sw'; el.style.background=c;
    if(c===selectedColor) el.classList.add('sel');
    el.addEventListener('click', ()=>{ selectedColor=c; paletteEl.querySelectorAll('.sw').forEach(x=>x.classList.remove('sel')); el.classList.add('sel'); });
    paletteEl.appendChild(el);
  });
}

let drawing=false, lastX=0, lastY=0;
function localColor(){ return currentMode==='eraser' ? '__erase__' : selectedColor; }
function strokeLine(x1,y1,x2,y2,color,width){
  ctx.save();
  if(color==='__erase__'){ ctx.globalCompositeOperation='destination-out'; ctx.strokeStyle='rgba(0,0,0,1)'; }
  else { ctx.globalCompositeOperation='source-over'; ctx.strokeStyle=color; }
  ctx.lineWidth=width; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); ctx.restore();
}
function applyRemoteStroke(pkt){ strokeLine(pkt.x1,pkt.y1,pkt.x2,pkt.y2,pkt.col, pkt.w||brushSize*dpr()); }

function getPos(e){
  const rect=canvas.getBoundingClientRect(), r=dpr();
  let x,y;
  if(e.touches && e.touches[0]){ x=(e.touches[0].clientX-rect.left)*r; y=(e.touches[0].clientY-rect.top)*r; }
  else { x=(e.clientX-rect.left)*r; y=(e.clientY-rect.top)*r; }
  return {x:Math.round(x), y:Math.round(y)};
}

canvas.addEventListener('pointerdown', e=>{
  canvas.setPointerCapture(e.pointerId);
  drawing=true; const p=getPos(e); lastX=p.x; lastY=p.y;
});
canvas.addEventListener('pointermove', e=>{
  if(!drawing) return;
  const p=getPos(e), col=localColor(), w=Math.max(1,brushSize)*dpr();
  strokeLine(lastX,lastY,p.x,p.y,col,w);
  safeBroadcast({type:'draw', x1:lastX,y1:lastY,x2:p.x,y2:p.y, col, w});       // 변경됨: 안전 브로드캐스트
  lastX=p.x; lastY=p.y;
});
canvas.addEventListener('pointerup', e=>{ drawing=false; try{canvas.releasePointerCapture(e.pointerId)}catch(_){} });
canvas.addEventListener('pointercancel', ()=>{ drawing=false; });

brushSizeInput.addEventListener('input', ()=>{ brushSize = Math.max(1, parseInt(brushSizeInput.value||'2',10)); });
modeDrawBtn.addEventListener('click', ()=>{ currentMode='draw';  modeDrawBtn.disabled=true; modeEraserBtn.disabled=false; });
modeEraserBtn.addEventListener('click', ()=>{ currentMode='eraser';modeDrawBtn.disabled=false; modeEraserBtn.disabled=true; });

function exportDrawing(){ try{ return {img: canvas.toDataURL()}; }catch(e){ return null; } }
function importDrawing(obj){ if(!obj||!obj.img) return; const img=new Image(); img.onload=()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); }; img.src=obj.img; }

buildPalette();
fitCanvas();
startP2P();                                                                     // 변경됨: 링크방 + STUN/TURN 구성으로 시작
</script>
</body>
</html>